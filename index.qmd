---
title: "RP1"
author: "Gezhi Chen"

execute:
  echo: false
  
bibliography: references.bib
---

> **Abstract.** This is a suggested formatting for your abstract. This **quarto** document is a template for your report. It includes some basic ways of working with such documents. You are invited to learn more about developing online reports with this technology.
>
> **Keywords.** bsvars, quarto, R, Australia inflation rate

# Introduction

## The question objective, and motivation

**Objective:**

The purpose of this research is to explore the trend in Australia's inflation rate over the next two years.

**Question:**

Will Australia's inflation rate fall back to the 2-3% inflation target range in 2025, and will it reach 2.5% in 2026?

The Reserve Bank of Australia (RBA) forecasts that inflation will fall back to the target range of 2% to 3% by 2025 and reach the midpoint of this range in 2026. The purpose of the study is to forecast inflation over the next two years and assess the reasonableness of the RBA's forecast. This is because we have observed a sharp rise in inflation to 7.8% during COVID-19, and in response the RBA implemented tightening monetary policy and increased interest rates starting in late 2022. Entering mid-to-late 2023, the pace of interest rate increases has slowed down. This research will help determine whether the RBA correctly assumed that its monetary policy measures have effectively suppressed inflation and expected that inflation will fall back to the target range over the next year.

```{r Library}
#| echo: false
#| message: false
#| warning: false

library(readabs)
library(readrba)
library(xts)
library(fUnitRoots)   # ADF test - adfTest
library(tidyverse)    # for table
library(kableExtra)   # for print table
```

## Data and their properties

### Data Selection and Rationale

-   **Direct Inflationary Indicators:**

    1.$cpi_i$: Consumer Price Index (CPI): Direct measure of inflation (from ABS)

    2.$gold_i$: Gold price, indicate inflationary expectations (from yahoo finance)

-   **Economic Activity and Policy Indicators:**

    3.$gdp_i$: Gross Domestic Product (GDP), reflect economic growth and demand-pull inflation (from ABS)

    4.$crt_i$: Cash rate target, Indicate monetary policy stance which affects inflation (from RBA)

    5.$unemp_i$: Unemployment rate, indicate the level of slack in the labor market, influencing wage-push inflation (from ABS)

-   **Market and External Trade Indicators:**

    6.$nloan_i$: New loan commitments, reflect credit growth which can fuel economic activity and inflation (from ABS)

    7.$export_i$: International exports, affect trade balance and currency strength, influencing imported inflation (from ABS)

    8.$import_i$: International imports: Directly affect inflation through the cost of imported goods (from ABS)

    9.$aord_i$: All Ordinaries Index (AORD), reflects investor confidence and economic activity which can be pre-emptive indicators of inflation (from yahoo finance)

    10.$exr_i$: AUD/USD exchange rate, affects the price of imports and exports, contributing to inflation (from yahoo finance)

```{r Data downloading, fig.pos="H"}
#| echo: false
#| message: false
#| warning: false

### Data downloading

# 1.Inflation / CPI 
# 6401.0 Consumer Price Index, Australia
# series_id = "A2325846C": Index Numbers ;  All groups CPI ;  Australia ;
cpi_download  = read_abs(series_id = "A2325846C")     
cpi_data      = xts(cpi_download$value, cpi_download$date)

# 2.GDP
# 5206.0 Australian National Accounts: National Income, Expenditure and Product
# series_id = "A2304404C": GDP per capita: Chain volume measures ;
gdp_download  = read_abs(series_id = "A2304404C")     
gdp_data      = xts(gdp_download$value, gdp_download$date)

# 3.Cash rate target

crt_download   = read_rba(series_id = "FIRMMCRTD")   
crt_data       = xts(crt_download$value, crt_download$date)
crt_data       = apply.quarterly(crt_data, mean)     # change daily to quarterly
crt_data       = xts(crt_data, seq(as.Date("1990-03-01"), by = "quarter", length.out = length(crt_data)))

# 4.Unemployment rate
# 6202.0 Labour Force, Australia
# series_id = "A84423050A": Unemployment rate ;  Persons ; seasonal adjust
unemp_download = read_abs(series_id = "A84423050A")     
unemp_data     = xts(unemp_download$value, unemp_download$date)
unemp_data     = apply.quarterly(unemp_data, mean) # change daily to quarterly
unemp_data     = xts(unemp_data, seq(as.Date("1978-03-01"), by = "quarter", length.out = length(unemp_data)))

# 5.Export
# 5368.0 International Trade in Goods
# series_id = "A2718603V": Debits, Total goods ;
export_download = read_abs(series_id = "A2718603V")     
export_data     = xts(export_download$value, export_download$date)
export_data     = abs(export_data)
export_data     = apply.quarterly(export_data, mean)
 
# 6.Import
# 5368.0 International Trade in Goods
# series_id = "A2718577A": Credits, Total goods ;
import_download  = read_abs(series_id = "A2718577A")     
import_data      = xts(import_download$value, import_download$date)
import_data      = apply.quarterly(import_data, mean)

# 7.New loan
# 5601.0 Lending Indicators
# series_id = "A108296973X"ï¼š Households ;  Housing Finance ;  Total housing excluding refinancing ;  New loan commitments ;  Value ; seasonal adjust
nloan_download   = read_abs(series_id = "A108296973X")     
nloan_data       = xts(nloan_download$value, nloan_download$date)
nloan_data       = apply.quarterly(nloan_data, mean)


# 8.Gold price
gold_link       = "https://query1.finance.yahoo.com/v7/finance/download/GC%3DF?period1=1262304000&period2=1703980800&interval=1mo&filter=history&frequency=1mo&includeAdjustedClose=true"
gold_download   = read.csv(gold_link)
gold_data       = gold_download[,6]
gold_data       = data.frame(gold_download[,1], gold_data)
colnames(gold_data) = c('date', 'gol')
gold_data$date  = as.Date(as.character(gold_data$date),format="%Y-%m-%d") 
gold_data       = xts(gold_data$gol, gold_data$date)
gold_data       = apply.quarterly(gold_data, mean)

# 9.AORD
aord_link       = "https://query1.finance.yahoo.com/v7/finance/download/%5EAORD?period1=1262304000&period2=1703980800&interval=1mo&filter=history&frequency=1mo&includeAdjustedClose=true"
aord_download   = read.csv(aord_link)
aord_data       = aord_download[,6]
aord_data       = data.frame(aord_download[,1], aord_data)
colnames(aord_data) = c('date', 'aord')
aord_data$date  = as.Date(as.character(aord_data$date),format="%Y-%m-%d") 
aord_data       = xts(aord_data$aord, aord_data$date)
aord_data       = apply.quarterly(aord_data, mean)

# 10. AUD/USD
exr_link        = "https://query1.finance.yahoo.com/v7/finance/download/AUDUSD%3DX?period1=1262304000&period2=1703980800&interval=1mo&filter=history&frequency=1mo&includeAdjustedClose=true"
exr_download    = read.csv(exr_link)
exr_data        = exr_download[,6]
exr_data        = data.frame(exr_download[,1], exr_data)
colnames(exr_data) = c('date', 'exr')
exr_data$date   = as.Date(as.character(exr_data$date),format="%Y-%m-%d") 
exr_data        = xts(exr_data$exr, exr_data$date)
exr_data        = apply.quarterly(exr_data, mean)




```

```{r Data combine, fig.pos="H"}
#| echo: false
#| message: false
#| warning: false

# All Variables
all_data             = na.omit(merge(cpi_data,    gold_data, 
                                     gdp_data,    crt_data, 
                                     unemp_data,  nloan_data,  
                                     export_data, import_data, 
                                     aord_data,   exr_data ))
colnames(all_data)   = c("cpi_data",    "gold_data", 
                         "gdp_data",    "crt_data", 
                         "unemp_data",  "nloan_data", 
                         "export_data", "import_data",
                         "aord_data",   "exr_data")
```

### Data Transformation

-   **Log Transformation**

Based on the line graph of the original data below (Figure 1), we can observe that exponentially growing variables need to be linearized, such as $cpi_i$, $export_i$, $import_i$, $exr_i$. Therefore, its logarithmically transformed form will be used in the following analysis.

```{r Data plot, fig.align='center',fig.pos='H'}
#| echo: false
#| message: false
#| warning: false

### Data plot

## Line plot for original data
par(mfcol = c(5, 2), mar = c(2, 2, 2, 2))

for (i in 1:10) {
  ts.plot(all_data[, i], main = colnames(all_data)[i], 
          ylab = "", xlab = "", col = "darkblue")
}
```

Figure 1 Line graph of original data

```{r Log transfomation}

## log transformation for exp data

lcpi_data  =  log(cpi_data)
lexport_data= log(export_data)
limport_data=  log(import_data)
lexr_data = log(exr_data)


# All Variables after log
all_data             = na.omit(merge(lcpi_data,    gold_data, 
                                     gdp_data,     crt_data, 
                                     unemp_data,   nloan_data,  
                                     lexport_data, limport_data, 
                                     aord_data,    lexr_data ))

colnames(all_data)   = c("lcpi_data",     "gold_data", 
                         "gdp_data",      "crt_data", 
                         "unemp_data",    "nloan_data", 
                         "lexport_data",  "limport_data",
                         "aord_data",     "lexr_data")
```

-   **Integration transformation**

According to ACF plot for all data (Figure 2), we can see all data with autocorrelation. It suggests that the series is not white noise and might not be stationary. In this case, applying a differencing operation, such as a first difference (single-order integration), can help remove the autocorrelation and achieve stationary.

```{r ACF plot, fig.align='center',fig.pos='H'}
#| echo: false
#| message: false
#| warning: false

## ACF plot
par(mfcol = c(5, 2), mar=c(2,2,2,2))
for (i in 1:10){
  acf = acf(all_data[,i], plot = FALSE)[1:20]
  plot(acf, main = "")
  title(main = paste(colnames(all_data)[i]), line = 0.5)
}
```

Figure 2 ACF Plot for all data

Considering the selection of the order of single-order integration, the unit root test (ADF test) is used and the p value is used to determine its significance. A small p-value means the null hypothesis is rejected (non-stationary).

According to Table 1, we can see that $cpi_i$, $crt_i$, $nloan_i$ and $limport_i$ require more than second-order integration, while $gold_i$, $unemp_i$, $lexport_i$ require sencond-order integration, other variables require first-order integration (under 10% level of confidence and n in the table means larger than 2).

```{r ACF test, fig.align='center',fig.pos='H'}
#| echo: false
#| message: false
#| warning: false

## AR

# find the optimal lag 
ar_results <- list()

for (i in 1:ncol(all_data)) {
  ol.aic.ar <- ar(all_data[,i], order.max=20, aic=TRUE, method="ols")
  
  ar_results[[colnames(all_data)[i]]] <- ol.aic.ar$order
}

## ADF test

# ol.cpi.aic.ar$order
adf.cpi   = adfTest(all_data[,1], lags=17, type="c")              # don't reject -> non-stationary
dadf.cpi  = adfTest(diff(all_data[,1]), lags=16, type="nc")        # don't reject -> non-stationary
d2adf.cpi = adfTest(diff(diff(all_data[,1])), lags=15, type="nc")  # reject -> (I2 is stationary)
# adf.cpi@test$p.value
#-> integration order = 

# ol.gold.aic.ar$order
adf.gold   = adfTest(all_data[,2], lags=18, type="c")               # don't reject -> non-stationary
dadf.gold  = adfTest(diff(all_data[,2]), lags=17, type="nc")        # don't reject -> non-stationary
d2adf.gold = adfTest(diff(diff(all_data[,2])), lags=16, type="nc")  # reject -> (I2 is stationary)
# adf.gold@test$p.value
#-> integration order = 2

# ol.gdp.aic.ar$order
adf.gdp   = adfTest(all_data[,3], lags=1, type="c")              # don't reject -> non-stationary
dadf.gdp  = adfTest(diff(all_data[,3]), lags=0, type="nc")       # reject -> (I1 is stationary)
# adf.gdp@test$p.value
#-> integration order = 1

# ol.crt.aic.ar$order
adf.crt  = adfTest(all_data[,4], lags=20, type="c")               # don't reject -> non-stationary
dadf.crt = adfTest(diff(all_data[,4]), lags=19, type="nc")        # don't reject -> non-stationary
d2adf.crt = adfTest(diff(diff(all_data[,4])), lags=18, type="nc") # don't reject -> non-stationary
# d2adf.crt@test$p.value
#-> integration order = 

# ol.unemp.aic.ar$order
adf.unemp  = adfTest(all_data[,5], lags=20, type="c")           # don't reject -> non-stationary
dadf.unemp = adfTest(diff(all_data[,5]), lags=19, type="nc")    # don't reject -> non-stationary
d2adf.unemp = adfTest(diff(diff(all_data[,5])), lags=18, type="nc")    # don't reject -> non-stationary
# adf.unemp@test$p.value
#-> integration order = 2

# ol.nloan.aic.ar$order
adf.nloan  = adfTest(all_data[,6], lags=20, type="c")           # don't reject -> non-stationary
dadf.nloan = adfTest(diff(all_data[,6]), lags=19, type="nc")    # don't reject -> non-stationary
d2adf.nloan = adfTest(diff(diff(all_data[,6])), lags=18, type="nc")    # don't reject -> non-stationary
# adf.nloan@test$p.value
#-> integration order = 

# ol.export.aic.ar$order
adf.export  = adfTest(all_data[,7], lags=20, type="c")           # don't reject -> non-stationary
dadf.export = adfTest(diff(all_data[,7]), lags=19, type="nc")    # reject -> (I1 is stationary)
d2adf.export = adfTest(diff(diff(all_data[,7])), lags=18, type="nc")    # don't reject -> non-stationary
# adf.export@test$p.value
#-> integration order = 2

# ol.import.aic.ar$order
adf.import  = adfTest(all_data[,8], lags=20, type="c")           # don't reject -> non-stationary
dadf.import = adfTest(diff(all_data[,8]), lags=19, type="nc")    # don't reject -> non-stationary
d2adf.import = adfTest(diff(diff(all_data[,8])), lags=18, type="nc")    # don't reject -> non-stationary
d2adf.import@test$p.value
#-> integration order = 

# ol.aord.aic.ar$order
adf.aord   = adfTest(all_data[,9], lags=7, type="c")               # don't reject -> non-stationary
dadf.aord  = adfTest(diff(all_data[,9]), lags=6, type="nc")        # reject -> (I1 is stationary)
# adf.aord@test$p.value
#-> integration order = 1

# ol.exr.aic.ar$order
adf.exr   = adfTest(all_data[,10], lags=20, type="c")               # don't reject -> non-stationary
dadf.exr  = adfTest(diff(all_data[,10]), lags=19, type="nc")        # reject -> (I1 is stationary)
# adf.exr@test$p.value
# #-> integration order = 1

Unit_Root_Test_table <- 
  tibble( " " = c("lcpi", "gold", "gdp", "crt", "unemp", "nloan", "lexport","limport", "aord", "lexr"),
          "p value of ADF test of AR" 
          = round(c(adf.cpi@test$p.value,    adf.gold@test$p.value,
                    adf.gdp@test$p.value,    adf.crt@test$p.value,    
                    adf.unemp@test$p.value,  adf.nloan@test$p.value,
                    adf.export@test$p.value, adf.import@test$p.value,
                    adf.aord@test$p.value,   adf.exr@test$p.value),4),
          "p value of ADF test of diff-AR" 
          = round(c(dadf.cpi@test$p.value,    dadf.gold@test$p.value,
                    dadf.gdp@test$p.value,    dadf.crt@test$p.value,    
                    dadf.unemp@test$p.value,  dadf.nloan@test$p.value,
                    dadf.export@test$p.value, dadf.import@test$p.value,   
                    dadf.aord@test$p.value,   dadf.exr@test$p.value),4),
          "p value of ADF test of diff-diff-AR" 
          = round(c(d2adf.cpi@test$p.value,   d2adf.gold@test$p.value,
                    NA,                       d2adf.crt@test$p.value,
                    d2adf.unemp@test$p.value, d2adf.nloan@test$p.value, 
                    d2adf.export@test$p.value,d2adf.import@test$p.value,
                    NA, NA
                    ),4),
          "conclusion" 
          = c("lcpi~I(n)",    "gold~I(2)", 
              "gdp~I(1)",    "crt~I(n)",    
              "unemp~I(2)",  "nloan~I(n)", 
              "lexport~I(2)", "limport~I(n)", 
              "aord~I(1)",   "lexr~I(1)"
          ),
  )

# use 10% los, n>2

kable(Unit_Root_Test_table, align = "c") %>% 
  kable_styling(font_size = 8, 
                fixed_thead = TRUE, 
                full_width = FALSE, 
                position = "center",
                latex_options = c("HOLD_position"),
                bootstrap_options = c("striped", "hover", "bordered", "responsive", "dark"))

```

Table 1 Unit root test for all data

Since the second-order difference may remove part of the long-term information (such as trends) in the data, this may be detrimental to time series data such as $cpi_i$ and $crt_i$ that contain important trend information. Therefore, only first-order differences are used for all data.

```{r I1 integration}
#| echo: false
#| message: false
#| warning: false

all_data         = na.omit(diff(all_data))
```

## The model and hypothesis

## References {.unnumbered}
